FFI Overview
============

The SJS FFI requires 3 components to describe foreign objects, for SJS to call into :

1. A type declaration file
2. A linkage declaration file
3. The implementation

These are demonstrated by files in this directory:

1. externalconsole.json declares the type for an external console object, which lives entirely
   outside the SJS source.
2. externalconsole.linkage.json declares some linking information about the external console, namely
   its boxing status and asks for a custom object indirection map to be generated by the compiler.
3. externalconsole.cpp gives the C++ implementation of externalconsole.log.

The main program is in externalconsole.js.  To compile:

    sjsc --extra-decls externalconsole.json
         --extra-objs externalconsole.cpp
         --native-libs externalconsole.linkage.json
         externalconsole.js

The result of this compilation will be an externalconsole.c holding the generated C code for the
program.  Note that in general, each of the flags just shown above takes a comma-separated list of
files.

The rest of this file gives a few notes on specific aspects of each file.

Type Declarations
-----------------
Type declarations follow a verbose, but simple format demonstrated exhaustively in
src/main/resources/environment.json, simply specifying the types for some objects that exist in the
top level global environment.  Early in development it may be convenient to write the type
declarations and then continue writing code by only type checking against the declarations, without
yet worrying about the implementation of foreign primitives, e.g.:

    sjsc --extra-delcs externalconsole.json
         --typecheck-only
         externalconsole.js

Linkage Declarations
--------------------
Linkage files follow another JSON format.  The file specifies an object with two properties:
globals, and indirections.

The former simply specifies, for each global given in the type
declaration file(s), whether the global is boxed or not.  In general, simply globally allocating a
closure pointer or object pointer with the appropriate name for the global and setting "boxed" to
false is sufficient.

The latter is a list of object indirection maps needed by the native implementations.  Intuitively,
for SJS to access some native-implemented object, that object needs an indirection table so SJS code
can locate fields.  An important thing to note is that in each entry in the "indirections" list, the
order of entries in the "fields" array is important!  It must correspond to the order of the box
pointers in the native object implementation!  And for optimizations to work correctly, the writable
field boxes that follow the box pointers must again be in the same order, and the read-only
properties must be listed before the writable properties.

Native Implementations
----------------------
Any valid input to a C++ compiler (specifically g++ or clang++) is valid to supply to the
--extra-objs flag; they're simply passed along to the compiler with the code generated from SJS
code.

Compiling SJS code generates an extra .h file with #define'd constants for accessing fields of SJS
objects.  External code may rely on this header.

src/main/resources/linkage.h defines a number of useful macros and C++ templates for constructing
native implementations of SJS objects.  See it and the contents of externalconsole.cpp for other
important notes on linking C++ and SJS.
